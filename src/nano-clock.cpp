/*
 * Stable Clock Signal Generator using Timer1 on Arduino Nano
 * Supports frequencies from ~1 Hz to ~4 MHz on Pin 9
 */
#include <Arduino.h>

const uint32_t clockFrequency = 1000; // Desired clock frequency in Hz

void selectPrescaler(uint32_t clockFrequency, uint16_t &prescaler);
void configureTimer1();
uint16_t calculateTopValue(uint32_t clockFrequency, uint16_t prescaler);
void handleTopValueLimits(uint16_t &topValue);

void setup() {
  pinMode(9, OUTPUT); // Pin 9 is connected to Timer1 (OC1A)
  configureTimer1();

  uint16_t prescaler = 1;
  uint16_t topValue = 0;

  selectPrescaler(clockFrequency, prescaler);
  topValue = calculateTopValue(clockFrequency, prescaler);
  handleTopValueLimits(topValue);

  OCR1A = topValue; // Set the TOP value for Timer1

  // Toggle OC1A (Pin 9) on compare match
  TCCR1A |= (1 << COM1A0);
}

void loop() {
  // Nothing needed here; clock is generated by hardware.
}

/**
 * @brief Selects the appropriate prescaler for Timer1 based on the given clock frequency.
 * 
 * Clears prescaler bits before setting the correct value.
 * 
 * @param clockFrequency The desired clock frequency in Hz.
 * @param prescaler The variable to store the selected prescaler value.
 */
void selectPrescaler(uint32_t clockFrequency, uint16_t &prescaler) {
  // Clear previous prescaler settings
  TCCR1B &= ~(1 << CS10 | 1 << CS11 | 1 << CS12);

  if (clockFrequency > 1000) {
    prescaler = 1;
    TCCR1B |= (1 << CS10); // No prescaling
  } else if (clockFrequency > 125) {
    prescaler = 8;
    TCCR1B |= (1 << CS11); // Prescaler = 8
  } else if (clockFrequency > 15) {
    prescaler = 64;
    TCCR1B |= (1 << CS11) | (1 << CS10); // Prescaler = 64
  } else if (clockFrequency > 2) {
    prescaler = 256;
    TCCR1B |= (1 << CS12); // Prescaler = 256
  } else {
    prescaler = 1024;
    TCCR1B |= (1 << CS12) | (1 << CS10); // Prescaler = 1024
  }
}

/**
 * @brief Configures Timer1 for CTC (Clear Timer on Compare Match) mode.
 * 
 * Stops Timer1, clears its control registers, and sets it to CTC mode.
 */
void configureTimer1() {
  // Stop Timer1 and clear control registers
  TCCR1A = 0;
  TCCR1B = 0;

  // Set Timer1 to CTC mode
  TCCR1B |= (1 << WGM12);
}

/**
 * @brief Calculates the TOP value for Timer1 based on the given clock frequency and prescaler.
 * 
 * Ensures the calculated value stays within 16-bit bounds.
 * 
 * @param clockFrequency The desired clock frequency in Hz.
 * @param prescaler The prescaler value used for Timer1.
 * @return uint16_t The calculated TOP value.
 */
uint16_t calculateTopValue(uint32_t clockFrequency, uint16_t prescaler) {
  uint32_t topValue = (16000000 / (2UL * prescaler * clockFrequency)) - 1;
  return (topValue > 65535) ? 65535 : static_cast<uint16_t>(topValue);
}

/**
 * @brief Handles the limits of the TOP value for Timer1.
 * 
 * Ensures the value is within the valid range for the timer and adjusts it for edge cases.
 * 
 * @param topValue The calculated TOP value for Timer1.
 */
void handleTopValueLimits(uint16_t &topValue) {
  if (topValue < 1) {
    topValue = 1; // Minimum valid TOP value
  } else if (topValue > 65535) {
    topValue = 65535; // Maximum valid TOP value
  }
}
